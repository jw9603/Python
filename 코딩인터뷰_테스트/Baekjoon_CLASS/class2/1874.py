# 백준 1874. 스택 수열
# https://www.acmicpc.net/problem/1874
########################## 문제 이해 ##########################
# 주어진 수열을 스택을 이용하여 만들 수 있는지 확인하고,
# 만들 수 있다면 그 과정에서 사용한 push와 pop의 순서를 출력한다.   
# 스택은 LIFO(Last In First Out) 구조이므로, 가장 최근에 들어간 요소가 먼저 나와야 한다.
# 입력으로는 수열의 길이 N과 N개의 정수가 주어진다.
# 출력으로는 수열을 만들기 위한 push와 pop의 순서를 나타내는 문자열을 출력한다.
# 만약 수열을 만들 수 없다면 "NO"를 출력한다.   
# 1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다.
# 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자.
# 즉, 1부터 n까지의 수를 순서대로 스택에 넣고, 필요할 때마다 pop하여 수열을 만들어야 한다.
# 스택에 넣는 순서는 항상 오름차순이므로, 수열의 각 원소가 스택의 최상단에 있는 원소와 일치하는지 확인해야 한다.
# 만약 일치하지 않는다면, 스택에 더 많은 원소를 넣어야 하며,
# 이때는 스택에 넣을 수 있는 다음 원소를 계속해서 넣어야 한다.
# 만약 수열의 원소가 스택의 최상단 원소와 일치하지 않고,
# 스택에 넣을 수 있는 다음 원소가 더 이상 없다면,
# 수열을 만들 수 없으므로 "NO"를 출력해야 한다.
# 수열을 만들 수 있다면, push와 pop의 순서를 출력해야 한다.
# push는 '+'로, pop은 '-'로 나타내며, 각 연산은 한 줄에 하나씩 출력한다.
# 예를 들어, 수열이 [4, 3, 6, 8, 7, 5, 2, 1]이라면,
# push와 pop의 순서는 다음과 같이 될 것이다:
# + (1을 push)
# + (2를 push)
# + (3을 push)
# + (4를 push)
# - (4를 pop)
# - (3을 pop)
# + (5를 push)
# + (6을 push)
# - (6을 pop)      
# + (7을 push)
# + (8을 push)
# - (8을 pop)
# - (7을 pop)
# - (3을 pop)
# - (2을 pop)
# - (1을 pop)
# 이 과정을 통해 수열을 만들 수 있다.

# 알고리즘
# 빈 스택을 먼저 생성
# 1부터 nums의 가장 큰 수 까지 순차적으로 push
# 스택의 최상단 원소와 nums의 현재 원소가 같으면 pop
# 같지 않으면 push를 계속 진행
# 그리고, 스택의 최상단 원소와 nums의 현재 원소가 같지 않고,
# 스택에 넣을 수 있는 다음 원소가 더 이상 없다면 "NO"
# 수열을 만들 수 있다면, push와 pop의 순서를 출력한다.
# push는 '+'로, pop은 '-'로 나타내며, 각 연산은 한 줄에 하나씩 출력한다.
########################## 문제 이해 ##########################
def sol(n, nums):
    stack = []
    result = []
    value = 1

    for num in nums:
        while not stack or stack[-1] < num:
            stack.append(value)
            value += 1
            result.append('+')
        if stack and stack[-1] == num:
            stack.pop()
            result.append('-')
        else:
            return "NO"
        
    return '\n'.join(result)

def main():
    n = int(input().strip())
    nums = [int(input().strip()) for _ in range(n)]
    print(sol(n, nums))

if __name__ == "__main__":
    main()